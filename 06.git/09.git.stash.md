# Git Stash

git stash 栈空间是开发者进行上下文切换的核心工具。在处理高并发交易系统等复杂逻辑时，灵活运用 stash 可以极大提升代码提交的原子性。

## 1. 常用核心操作

### 精细化入栈
- 基础入栈：git stash push -m "description"
- 包含未跟踪文件：git stash -u (处理新创建的 Golang 源文件时必用)
- 包含忽略文件：git stash -a (通常用于临时修改了本地环境配置的情况)

### 交互式入栈 (Patch 模式)
- 挑选修改：git stash -p
- 说明：此命令会进入交互界面，允许你逐个确认代码块（Hunks）。这对于只想暂存部分调试代码，而保留业务逻辑进行提交的场景非常有用。

### 状态查看与校验
- 简要列表：git stash list
- 查看详情：git stash show -p stash@{0} (查看暂存内容与当前分支的差异详情)
- 仅查看文件列表：git stash show stash@{0}

---

## 2. 高阶管理技巧

### 弹出逻辑的选择
- 应用并删除：git stash pop (默认行为，适用于单次恢复)
- 仅应用保留：git stash apply (在多个分支之间同步同一份临时修改时极其有用)
- 强制删除：git stash drop stash@{0}

### 从暂存区直接创建分支
- 场景：当你发现暂存的代码量过大，且与当前分支方向偏离时。
- 命令：git stash branch <new_branch_name> stash@{0}
- 效果：Git 会基于暂存发生时的那个提交点创建一个新分支，并把暂存内容应用上去。成功后会自动删除该 stash 记录。

### 暂存特定路径
- 场景：只想暂存某个特定的模块代码，例如只暂存 ./internal/trading 目录。
- 命令：git stash push -m "only trading logic" ./internal/trading

---

## 3. 架构师级工作流

### 配合 Rebase 保持线性历史
- 逻辑：在执行 git pull --rebase 之前，先 git stash。
- 流程：
  - git stash
  - git pull --rebase origin main
  - git stash pop
- 价值：避免了不必要的 Merge Commit，保持了交易系统代码库的提交历史清晰。

### 临时热修复场景
- 逻辑：正在 develop 开发中，main 需要紧急修复。
- 流程：
  - git stash (保存当前进度)
  - git checkout main
  - git checkout -b hotfix/api-leak
  - (修复并 commit)
  - git checkout develop
  - git stash pop (回到之前的开发状态)

---

## 4. 维护与防丢建议

- 命名规范：永远不要使用不带备注的 git stash。对于架构师来说，stash@{5} 这种默认命名是不可维护的。
- 冲突保护：如果 pop 时产生冲突，Git 不会自动删除 stash。必须手动修复冲突并 add 后，再手动执行 git stash drop。
- 定期清理：使用 git stash clear 之前务必确认 stash list 为空。
